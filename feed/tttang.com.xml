<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title type="text">跳跳糖 - 安全与分享社区</title>
  <link href="https://raw.githubusercontent.com/p7e4/ThirdPartyFeed/main/feed/tttang.com.xml" rel="self"/>
  <link rel="alternate" href="https://tttang.com/"/>
  <updated>2022-08-27T06:18:00+08:00</updated>
  <id>https://tttang.com/</id>
  <entry>
    <title type="text">若依(RuoYi)管理系统后台sql注入漏洞分析</title>
    <link rel="alternate" type="text/html" href="https://tttang.com/archive/1712/"/>
    <id>https://tttang.com/archive/1712/</id>
    <published>2022-08-26T12:00:00+08:00</published>
    <summary type="text">
      &lt;p&gt;若依管理系统是基于&lt;code&gt;SpringBoot&lt;/code&gt;框架开发的，并利用&lt;code&gt;MyBatis&lt;/code&gt;框架进行数据库操作。在RuoYi &amp;lt;=4.6.1版本中后台存在sql注入漏洞，本着对MyBatis框架中sql注入学习的态度，对该漏洞进行了以下分析。&lt;/p&gt;
    </summary>
  </entry>
  <entry>
    <title type="text">psexec原理分析和实现</title>
    <link rel="alternate" type="text/html" href="https://tttang.com/archive/1710/"/>
    <id>https://tttang.com/archive/1710/</id>
    <published>2022-08-25T12:00:00+08:00</published>
    <summary type="text">
      &lt;p&gt;psexec是&lt;code&gt;sysinternals&lt;/code&gt;提供的众多windows工具中的一个，这款工具的初衷是帮助管理员管理大量的机器的，后来被攻击者用来做横向渗透。&lt;/p&gt;
    </summary>
  </entry>
  <entry>
    <title type="text">利用 PHP-FPM 做内存马的方法</title>
    <link rel="alternate" type="text/html" href="https://tttang.com/archive/1720/"/>
    <id>https://tttang.com/archive/1720/</id>
    <published>2022-08-24T12:00:00+08:00</published>
    <summary type="text">
      &lt;p&gt;Java 内存马固然是极好的，可我略微瞟了一眼&lt;a href=&quot;https://w3techs.com/technologies/overview/programming_language&quot; target=&quot;_blank&quot;&gt;PHP 的占有率&lt;/a&gt;，虽然从我上次关注 PHP 10年都过去了，PHP 却仍然是最为主流的服务端 Web 语言。所以，为什么没人做 PHP 的内存马研究呢？&lt;/p&gt;
    </summary>
  </entry>
  <entry>
    <title type="text">一种新的Tomcat内存马 - Upgrade内存马</title>
    <link rel="alternate" type="text/html" href="https://tttang.com/archive/1709/"/>
    <id>https://tttang.com/archive/1709/</id>
    <published>2022-08-23T12:00:00+08:00</published>
    <summary type="text">
      &lt;p&gt;在渗透过程中，有些时候虽然我们植入了内存马，但是由于原有Filter的缘故，导致鉴权失败或者是无法访问，在亦或是由于反代的缘故，很多时候无法找到对应路径。为了解决这个问题，我们要在进入请求进入Filter之前进入内存马被拦截处理。&lt;/p&gt;
    </summary>
  </entry>
  <entry>
    <title type="text">基于USMA的内核通用EXP编写思路在 CVE-2022-34918 上的实践</title>
    <link rel="alternate" type="text/html" href="https://tttang.com/archive/1706/"/>
    <id>https://tttang.com/archive/1706/</id>
    <published>2022-08-22T12:00:00+08:00</published>
    <summary type="text">
      &lt;p&gt;书接上回&lt;a href=&quot;https://veritas501.github.io/2022_08_02-CVE-2022-34918%20netfilter%20%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0/&quot; target=&quot;_blank&quot;&gt;《CVE-2022-34918 netfilter 分析笔记》&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在上一篇文章中，我将360在blackhat asia 2022上提出的USMA利用方式实践于 CVE-2022-34918的利用过程中，取得了不错的利用效果，即绕过了内核诸多的防御措施。&lt;/p&gt;
&lt;p&gt;但唯一的缺点是，上次的利用脚本&lt;strong&gt;需要攻击者预先知道内核中的目标函数偏移&lt;/strong&gt;，而这往往是实际利用中&lt;strong&gt;最难获得的&lt;/strong&gt;。这也正是DirtyCow，DirtyPipe这些逻辑类漏洞相比于内存损坏类漏洞最大的优势。&lt;/p&gt;
&lt;p&gt;这篇文章我们再以CVE-2022-34918为模板，尝试让USMA在利用过程中不再依赖内核中的地址偏移，从而内存损坏型漏洞的exp能够和逻辑类漏洞一样具有普适性。&lt;/p&gt;
    </summary>
  </entry>
  <entry>
    <title type="text">从偶遇Flarum开始的RCE之旅</title>
    <link rel="alternate" type="text/html" href="https://tttang.com/archive/1714/"/>
    <id>https://tttang.com/archive/1714/</id>
    <published>2022-08-19T12:00:00+08:00</published>
    <summary type="text">
      &lt;p&gt;一次日常测试中，偶然遇到了一个Flarum搭建的论坛，并获得了其管理员账号。本来到这里已经可以算完成了任务，将漏洞报给具体负责的人就结束了，但是既然已经拿到了管理员账号，何不尝试一下RCE呢？&lt;/p&gt;
    </summary>
  </entry>
  <entry>
    <title type="text">CodeQL数据库构建原理分析</title>
    <link rel="alternate" type="text/html" href="https://tttang.com/archive/1704/"/>
    <id>https://tttang.com/archive/1704/</id>
    <published>2022-08-18T12:00:00+08:00</published>
    <summary type="text">
      &lt;p&gt;&lt;a href=&quot;https://github.com/github/codeql&quot; target=&quot;_blank&quot;&gt;CodeQL&lt;/a&gt;是一个帮助开发者自动完成安全检查、帮助安全研究者进行变异分析的分析引擎。它由代码数据库和代码语义分析引擎组成，通过将代码抽象为数据查询表保存到代码数据库中，可以方便地运行代码查询。本文的关注点在于CodeQL是如何生成代码数据库。&lt;/p&gt;
    </summary>
  </entry>
  <entry>
    <title type="text">二次反序列化 看我一命通关</title>
    <link rel="alternate" type="text/html" href="https://tttang.com/archive/1701/"/>
    <id>https://tttang.com/archive/1701/</id>
    <published>2022-08-17T12:00:00+08:00</published>
    <summary type="text">
      &lt;p&gt;不记得是哪一场比赛了，遇到了一个 Java 的题目，过滤了很多关键类，不管茯苓把 CC 链如何拆开组合，都没有办法绕过。&lt;/p&gt;
&lt;p&gt;就在此时，大佬看了一眼说，用二次反序列化就可以绕过了。“二次反序列化”这六个字重重地敲在了我的心巴上，从那以后我就对二次反序列化产生了莫名的渴望。&lt;/p&gt;
    </summary>
  </entry>
  <entry>
    <title type="text">XStream通览漏洞分析</title>
    <link rel="alternate" type="text/html" href="https://tttang.com/archive/1699/"/>
    <id>https://tttang.com/archive/1699/</id>
    <published>2022-08-16T12:00:00+08:00</published>
    <summary type="text">
      &lt;p&gt;XStream是一个简单的基于Java库，Java对象序列化到XML，反之亦然(即：可以轻易的将Java对象和xml文档相互转换)。&lt;/p&gt;
    </summary>
  </entry>
  <entry>
    <title type="text">FLask SSTI从零到入门</title>
    <link rel="alternate" type="text/html" href="https://tttang.com/archive/1698/"/>
    <id>https://tttang.com/archive/1698/</id>
    <published>2022-08-15T12:00:00+08:00</published>
    <summary type="text">
      &lt;p&gt;SSTI也是一个比较常见的注入，在学习过后，进行简单总结，希望能对正在学习SSTI的师傅有所帮助。&lt;/p&gt;
    </summary>
  </entry>
  <entry>
    <title type="text">A Magic Way of XSS in HTTP/2</title>
    <link rel="alternate" type="text/html" href="https://tttang.com/archive/1703/"/>
    <id>https://tttang.com/archive/1703/</id>
    <published>2022-08-12T12:00:00+08:00</published>
    <summary type="text">
      &lt;p&gt;上周周末结束的 corCTF 中有一个题目提出了一种很有意思的攻击，该攻击方式可以利用 HTTP/2 Server Push 机制 XSS 到其他域，尽管利用条件有点苛刻，但是我个人非常喜欢这种 Magic 的攻击方式。（在征求了原作者 &lt;a href=&quot;https://larry.sh/&quot; target=&quot;_blank&quot;&gt;@ehhthing&lt;/a&gt; 同意下将该方法分享给大家）&lt;/p&gt;
    </summary>
  </entry>
  <entry>
    <title type="text">The Poor Man&amp;#x27;s Obfuscator</title>
    <link rel="alternate" type="text/html" href="https://tttang.com/archive/1697/"/>
    <id>https://tttang.com/archive/1697/</id>
    <published>2022-08-11T12:00:00+08:00</published>
    <summary type="text">
      &lt;p&gt;影响或阻碍 IDA、BinaryNinja、Ghidra 和 Radare2 等反汇编工具的 ELF 或 Mach-O 修改。&lt;/p&gt;
&lt;p&gt;不会修改汇编代码或二进制数据。重点是修改可执行文件格式的一些结构，比如节区和符号。&lt;/p&gt;
&lt;p&gt;所有修改均基于LIEF，一个用于解析和修改可执行文件格式的库。&lt;/p&gt;
    </summary>
  </entry>
  <entry>
    <title type="text">tabby原理分析</title>
    <link rel="alternate" type="text/html" href="https://tttang.com/archive/1696/"/>
    <id>https://tttang.com/archive/1696/</id>
    <published>2022-08-10T12:00:00+08:00</published>
    <summary type="text">
      &lt;p&gt;&lt;a href=&quot;https://github.com/wh1t3p1g/tabby&quot; target=&quot;_blank&quot;&gt;tabby&lt;/a&gt;是一款基于&lt;a href=&quot;https://github.com/soot-oss/soot&quot; target=&quot;_blank&quot;&gt;soot&lt;/a&gt;实现的java静态代码分析工具，用于分析jar包，生成代码属性图。结合手工可以半自动地完成java反序列化链挖掘工作。&lt;/p&gt;
    </summary>
  </entry>
  <entry>
    <title type="text">WMI调试与检测</title>
    <link rel="alternate" type="text/html" href="https://tttang.com/archive/1640/"/>
    <id>https://tttang.com/archive/1640/</id>
    <published>2022-08-09T12:00:00+08:00</published>
    <summary type="text">
      &lt;p&gt;这是WMI的第三篇文章，本文主要调式分析WMI消费者的工作原理，进而提出WMI的检测思路。本文首先介绍了本次分析所需要了解的WMI基本组件和底层协议(RPC),然后通过调式网上的RPC客户端和服务端的通信，了解RPC的原理，接着通过分析两个典型的WMI利用(查询数据，执行函数)，了解WMI的检测，由于WMI调试相关资料过少，没有进行自我订正，可能存在错误，或者重大错误，希望有了解的大佬积极斧正。&lt;/p&gt;
    </summary>
  </entry>
  <entry>
    <title type="text">PowerPC PWN从入门到实践</title>
    <link rel="alternate" type="text/html" href="https://tttang.com/archive/1695/"/>
    <id>https://tttang.com/archive/1695/</id>
    <published>2022-08-08T12:00:00+08:00</published>
    <summary type="text">
      &lt;p&gt;前段时间2022虎符决赛结束，赛后从学长那看到了题目，其中出现了一道PowerPC64架构的pwn题，从架构方面来说比较少见，刚好之前看过一道PowerPC架构32位栈溢出的题目，于是放到一起整理一下。&lt;/p&gt;
    </summary>
  </entry>

</feed>
