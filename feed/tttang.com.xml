<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title type="text">跳跳糖 - 安全与分享社区</title>
  <link href="https://raw.githubusercontent.com/p7e4/ThirdPartyFeed/main/feed/tttang.com.xml" rel="self"/>
  <link rel="alternate" href="https://tttang.com/"/>
  <updated>2022-09-08T18:22:00+08:00</updated>
  <id>https://tttang.com/</id>
  <entry>
    <title type="text">原生反序列化链 jdk8u20 的新构造</title>
    <link rel="alternate" type="text/html" href="https://tttang.com/archive/1729/"/>
    <id>https://tttang.com/archive/1729/</id>
    <published>2022-09-08T12:00:00+08:00</published>
    <summary type="text">
      &lt;blockquote&gt;
&lt;p&gt;自己构造 jdk8u20 反序列化链子，构造思路比网上的大多数都简单很多，exp也更短&lt;/p&gt;
&lt;p&gt;感觉我之前那个 bypass &lt;code&gt;__wakeup()&lt;/code&gt; 的 trick 和 8u20 绕过 7u21 的方式异曲同工&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;jdk8u20 是对 jdk7u21 这条链的绕过&lt;/p&gt;
    </summary>
  </entry>
  <entry>
    <title type="text">dpt-shell抽取壳项目源码及其逆向分析</title>
    <link rel="alternate" type="text/html" href="https://tttang.com/archive/1728/"/>
    <id>https://tttang.com/archive/1728/</id>
    <published>2022-09-07T12:00:00+08:00</published>
    <summary type="text">
      &lt;p&gt;由于前段时间网鼎杯一道Android题目中用了这个，具有一定研究价值，便做一个壳的实现分析&lt;br&gt;
&lt;a href=&quot;https://github.com/luoyesiqiu/dpt-shell&quot; target=&quot;_blank&quot;&gt;https://github.com/luoyesiqiu/dpt-shell&lt;/a&gt;&lt;br&gt;
其实这个是一个假的抽取壳，虽然函数抽取壳确实是将dex文件中的函数代码给nop，然后在运行时再把字节码给填回，但是不会填回内存中原dex位置，是填回内存中的一个解析后的结构体，比如梆梆加固，普通的工具是dump不到dex的。&lt;br&gt;
虽然但是，能写出这个的也足以说明作者对Android的了解。即使作者也有howtowork文档去解释如何实现的，但是很多都被省略掉，这里做个源码分析，许多抽取壳也有类似的操作。&lt;/p&gt;
    </summary>
  </entry>
  <entry>
    <title type="text">codeql实践之查找house_of_kiwi利用点</title>
    <link rel="alternate" type="text/html" href="https://tttang.com/archive/1727/"/>
    <id>https://tttang.com/archive/1727/</id>
    <published>2022-09-06T12:00:00+08:00</published>
    <summary type="text">
      &lt;p&gt;codeql是一款强大的静态扫描工具，通过codeql强大的自定义规则我们可以编写sql语句来搜索源码中我们可能感兴趣的代码。ctf中高版本libc的利用方法中很多都用利用了IO函数，即利用stdin/stdout/stderr-&amp;gt;vtable 修改虚表指针指向对我们有用的伪造的vtable又或者其他存在可利用函数的_IO_xxx_jumps虚表，如：house_of_kiwi,因此我便诞生了使用codeql查找libc中所有跳转到IO的函数调用的想法，更方便的分析libc中的利用点，也看看能不能找出house_of_kiwi中使用的malloc_assert-&amp;gt;fflush利用点。&lt;/p&gt;
    </summary>
  </entry>
  <entry>
    <title type="text">JAVA常用框架SQL注入审计</title>
    <link rel="alternate" type="text/html" href="https://tttang.com/archive/1726/"/>
    <id>https://tttang.com/archive/1726/</id>
    <published>2022-09-05T12:00:00+08:00</published>
    <summary type="text">
      &lt;p&gt;总结常用Java框架SQL注入场景。&lt;/p&gt;
    </summary>
  </entry>
  <entry>
    <title type="text">浅析XML外部实体注入</title>
    <link rel="alternate" type="text/html" href="https://tttang.com/archive/1716/"/>
    <id>https://tttang.com/archive/1716/</id>
    <published>2022-09-02T12:00:00+08:00</published>
    <summary type="text">
      &lt;p&gt;在进行系统学习过后，对XXE进行简单总结，希望能对正在学习XXE的师傅有所帮助&lt;/p&gt;
    </summary>
  </entry>
  <entry>
    <title type="text">fuzzer AFL 源码分析（二）-fuzz流程</title>
    <link rel="alternate" type="text/html" href="https://tttang.com/archive/1686/"/>
    <id>https://tttang.com/archive/1686/</id>
    <published>2022-09-01T12:00:00+08:00</published>
    <summary type="text">
      &lt;p&gt;第一部分介绍了&lt;code&gt;afl&lt;/code&gt;插桩编译的过程，思考了很久才定下第二部分写些什么。本来打算第二部分详细解释插桩部分和&lt;code&gt;forkserver&lt;/code&gt;的代码的，但是感觉如果对&lt;code&gt;afl-fuzz&lt;/code&gt;的整体流程没有大致掌握的话，直接去描述细节会让人不理解为什么&lt;code&gt;afl&lt;/code&gt;这部分要这样去设计，因此决定在第二部分将&lt;code&gt;afl-fuzz&lt;/code&gt;的主要流程（&lt;code&gt;main&lt;/code&gt;）和部分不是关键代码的函数给说清楚，后续再逐步对关键代码模块进行详细分析，j继而实现对&lt;code&gt;afl&lt;/code&gt;模糊测试的解析。&lt;/p&gt;
    </summary>
  </entry>
  <entry>
    <title type="text">浅析路由器WEB服务架构（一）</title>
    <link rel="alternate" type="text/html" href="https://tttang.com/archive/1719/"/>
    <id>https://tttang.com/archive/1719/</id>
    <published>2022-08-31T12:00:00+08:00</published>
    <summary type="text">
      &lt;blockquote&gt;
&lt;p&gt;在路由器设备的漏洞挖掘当中，WEB服务通常都是安全研究人员重点关注的内容之一，安全研究员拿到一个设备之后，都会去对这个设备的攻击面进行收集与分析，但可以不可以一拿到设备的固件看到文件夹的结构就知道这个路由器的攻击面呢？网上似乎也没有这种总结从路由器WEB服务架构看路由器的攻击面的文章，这些路由器的WEB架构看着都有相似的点，也有不同之处，那到底是哪里相同，哪里不同呢？作为一个WEB小萌新，对此类概念还很模糊，接下来就来探讨一下吧！&lt;/p&gt;
&lt;/blockquote&gt;
    </summary>
  </entry>
  <entry>
    <title type="text">UAC 原理与检测</title>
    <link rel="alternate" type="text/html" href="https://tttang.com/archive/1715/"/>
    <id>https://tttang.com/archive/1715/</id>
    <published>2022-08-30T12:00:00+08:00</published>
    <summary type="text">
      &lt;p&gt;任何需要管理员访问令牌的程序都必须征得同意(即UAC弹窗)，但是存在一个意外，即父进程和子进程之间存在关系，即子进程从父进程中继承访问令牌，这是UAC 绕过的基础。本文将选择UACME中的3种不同的ByPass UAC的例子，为各位讲解ByPass UAC的原理。然后分析UAC的基本基本原理，继而寻找ByPass UAC的通用检测策略，本文行文仓促，如有错误，请各位积极指正。&lt;/p&gt;
    </summary>
  </entry>
  <entry>
    <title type="text">ATT&amp;amp;CK中的攻与防——T1059</title>
    <link rel="alternate" type="text/html" href="https://tttang.com/archive/1718/"/>
    <id>https://tttang.com/archive/1718/</id>
    <published>2022-08-29T12:00:00+08:00</published>
    <summary type="text">
      &lt;p&gt;为什么会有此篇文章，随着攻防大环境的深入，ATT&amp;amp;CK攻防矩阵也逐渐步入各个企业视野，越来越多的企业采用ATT&amp;amp;CK矩阵来作为反入侵检测，但是笔者很少看到有文章具体分析每一条策略的检测逻辑已经绕过方案，WINDOWS端的或许是零零碎碎的技术细节，MAC的更无从谈起，笔者从事安全的时间也不长，对于ATT&amp;amp;CK矩阵的了解也只能是略知一二，本文就以T1059策略作为切入点，分析一下ATT&amp;amp;CK矩阵中的攻与防，如果读者认为此篇文章能学到一些不一样的东西，笔者自然是很开心，笔者后续也会把ATT&amp;amp;CK矩阵的所有TTP做一个技术分析。&lt;/p&gt;
    </summary>
  </entry>
  <entry>
    <title type="text">若依(RuoYi)管理系统后台sql注入漏洞分析</title>
    <link rel="alternate" type="text/html" href="https://tttang.com/archive/1712/"/>
    <id>https://tttang.com/archive/1712/</id>
    <published>2022-08-26T12:00:00+08:00</published>
    <summary type="text">
      &lt;p&gt;若依管理系统是基于&lt;code&gt;SpringBoot&lt;/code&gt;框架开发的，并利用&lt;code&gt;MyBatis&lt;/code&gt;框架进行数据库操作。在RuoYi &amp;lt;=4.6.1版本中后台存在sql注入漏洞，本着对MyBatis框架中sql注入学习的态度，对该漏洞进行了以下分析。&lt;/p&gt;
    </summary>
  </entry>
  <entry>
    <title type="text">psexec原理分析和实现</title>
    <link rel="alternate" type="text/html" href="https://tttang.com/archive/1710/"/>
    <id>https://tttang.com/archive/1710/</id>
    <published>2022-08-25T12:00:00+08:00</published>
    <summary type="text">
      &lt;p&gt;psexec是&lt;code&gt;sysinternals&lt;/code&gt;提供的众多windows工具中的一个，这款工具的初衷是帮助管理员管理大量的机器的，后来被攻击者用来做横向渗透。&lt;/p&gt;
    </summary>
  </entry>
  <entry>
    <title type="text">利用 PHP-FPM 做内存马的方法</title>
    <link rel="alternate" type="text/html" href="https://tttang.com/archive/1720/"/>
    <id>https://tttang.com/archive/1720/</id>
    <published>2022-08-24T12:00:00+08:00</published>
    <summary type="text">
      &lt;p&gt;Java 内存马固然是极好的，可我略微瞟了一眼&lt;a href=&quot;https://w3techs.com/technologies/overview/programming_language&quot; target=&quot;_blank&quot;&gt;PHP 的占有率&lt;/a&gt;，虽然从我上次关注 PHP 10年都过去了，PHP 却仍然是最为主流的服务端 Web 语言。所以，为什么没人做 PHP 的内存马研究呢？&lt;/p&gt;
    </summary>
  </entry>
  <entry>
    <title type="text">一种新的Tomcat内存马 - Upgrade内存马</title>
    <link rel="alternate" type="text/html" href="https://tttang.com/archive/1709/"/>
    <id>https://tttang.com/archive/1709/</id>
    <published>2022-08-23T12:00:00+08:00</published>
    <summary type="text">
      &lt;p&gt;在渗透过程中，有些时候虽然我们植入了内存马，但是由于原有Filter的缘故，导致鉴权失败或者是无法访问，在亦或是由于反代的缘故，很多时候无法找到对应路径。为了解决这个问题，我们要在进入请求进入Filter之前进入内存马被拦截处理。&lt;/p&gt;
    </summary>
  </entry>
  <entry>
    <title type="text">基于USMA的内核通用EXP编写思路在 CVE-2022-34918 上的实践</title>
    <link rel="alternate" type="text/html" href="https://tttang.com/archive/1706/"/>
    <id>https://tttang.com/archive/1706/</id>
    <published>2022-08-22T12:00:00+08:00</published>
    <summary type="text">
      &lt;p&gt;书接上回&lt;a href=&quot;https://veritas501.github.io/2022_08_02-CVE-2022-34918%20netfilter%20%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0/&quot; target=&quot;_blank&quot;&gt;《CVE-2022-34918 netfilter 分析笔记》&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在上一篇文章中，我将360在blackhat asia 2022上提出的USMA利用方式实践于 CVE-2022-34918的利用过程中，取得了不错的利用效果，即绕过了内核诸多的防御措施。&lt;/p&gt;
&lt;p&gt;但唯一的缺点是，上次的利用脚本&lt;strong&gt;需要攻击者预先知道内核中的目标函数偏移&lt;/strong&gt;，而这往往是实际利用中&lt;strong&gt;最难获得的&lt;/strong&gt;。这也正是DirtyCow，DirtyPipe这些逻辑类漏洞相比于内存损坏类漏洞最大的优势。&lt;/p&gt;
&lt;p&gt;这篇文章我们再以CVE-2022-34918为模板，尝试让USMA在利用过程中不再依赖内核中的地址偏移，从而内存损坏型漏洞的exp能够和逻辑类漏洞一样具有普适性。&lt;/p&gt;
    </summary>
  </entry>
  <entry>
    <title type="text">从偶遇Flarum开始的RCE之旅</title>
    <link rel="alternate" type="text/html" href="https://tttang.com/archive/1714/"/>
    <id>https://tttang.com/archive/1714/</id>
    <published>2022-08-19T12:00:00+08:00</published>
    <summary type="text">
      &lt;p&gt;一次日常测试中，偶然遇到了一个Flarum搭建的论坛，并获得了其管理员账号。本来到这里已经可以算完成了任务，将漏洞报给具体负责的人就结束了，但是既然已经拿到了管理员账号，何不尝试一下RCE呢？&lt;/p&gt;
    </summary>
  </entry>

</feed>
